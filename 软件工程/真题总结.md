

# 理论应用题

1. 请画出传统软工生命周期模型与现代软工开发模型，论述二者的特点和不同。论述自己的实践项目开发属于哪一种模型

- 传统软工生命周期模型，即瀑布模型

定义：线性的安排每一个阶段 将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段 。一个开发阶段必须在另一个开发阶段开始之前完成

特点：

1. 只有前一阶段工作完成以后，后一阶段的工作才能开始
2. 尽可能推迟软件的编码
3. 保证质量，在每个阶段都要完成规定的文档，每个阶段都要对已完成的文档进行复审

优点：

1. 它的简单性使得开发人员很容易向不熟悉软件开发的客户作出解释
   1.  每一个过程活动都有 其相关联的里程碑和可交付产品十 以便千项目经理评估项目进度。

2. 瀑布模型是最基础的模型，很多其他更复杂的模型实际上以瀑布模型为基础，如加入正反馈以及额外的活动。

缺点：

1. 缺乏灵活性，不能反映实际的代码开发方式
2. 文档转换有困难
3. 缺乏灵活性，不能反映实际的代码开发方式
4. 无法及时验证某一软件开发活动是否正确，最终产品直到最后一个步骤才出现，而软件客户无法在早期直到软件原型

适用场合

1. 技术和需求都到位：当有一个稳定的产品定义和很容易被理解的技术解决方案时，纯瀑布模型特别合适
2. 容易理解的顺序处理方法（体力活）：对于那些容易理解但很复杂的项目，采用纯瀑布模型比较合适，因为可以用顺序方法处理问题
3. 对质量要求较高：在质量需求高于成本需求和进度需求的时候，它尤为出色
4. 适合于小白：当开发队伍的技术力量比较弱或者缺乏经验时，瀑布模型更为适合



- 现代软工开发模型，即敏捷开发模型

特点：

1. 个体和交互的价值胜过过程和工具
2. 可以工作的软件胜过面面俱到的文档
3. 客户合作胜过合同谈判
4. 相应变换胜过遵循计划



- 敏捷开发和现代软件工程开发的不同

1. 传统软工模型生命周期十分庞大，而敏捷方法打破了这种局面
2. 敏捷方法强调灵活性在快速有效的软件生产中发挥作用，而瀑布模型强调线性的安排每一个阶段，将开发阶段描述为一个从阶段瀑布般的转化到另一个阶段，并且一个开发阶段必须要在另一个开发阶段之前完成。
3. 敏捷方法强调尽可能早的、持续的对有价值的软件的交付活动，令客户满意，而瀑布模型强调线性的安排每一个阶段，保证最终交付。



- 结合自己的项目：

  我们的小米便签实践项目采用敏捷开发模型，主要由一下几点原因

  1. 人员因素：组内成员工程性经验较少，但是算法基础扎实，自学能力强。因此我们划分各自负责的模块之后自主学习并定期汇报，体现了敏捷开发中强调个体和交互的价值
  2. 项目架构层面：由于经验的匮乏，我们不能保证在一开始的时候确定整体的功能框架，也不能保证每一个增量开发都是规模小、功能鲁邦的子系统。因此我们不采用瀑布模型。
  3. 从开发角度：我们采用敏捷开发模型，可以及时扩展新的功能，并多次测试，及时的修正使用过程中出现的错误。





2. 论述德米特法则，结合项目并说明

- 论述德米特法则

德米特法则又叫做最少知识原则，一个雷对于其他类知道的越少越好，即任何一个对象或者方法，只能调用下列对象。

1. 当前对象本身（this）
2. 以参量形式传入到当前对象方法中的对象
3. 当前对象的实例变量直接引用的变量
4. 当前对象的实例如果是一个聚集，那么聚集中的元素也是朋友
5. 当前对象所创建的对象

德米特法则的原则就是类间解耦，弱耦合。只有弱耦合之后，类之间的复用率才会高，具体到代码层面，德米特法则要求尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等关键字。





3. 请列举出几种软件开发团队的组织形式，并论述各自的特点。结合自己的小组论述理想的团队组织是怎么样的

- 软件开发团队的组织结构有主程序员负责制和忘我方法

- 主程序员负责制

  由一个主程序员负责系统设计和开发，其他成员向其汇报。主程序员对每一个决定有绝对的决策权。其特点是使交流最小化，可以迅速的作出决定，缺点是创造性低，对主程序员要求较高

- 忘我方法

  忘我方法中每一个成员都是平等的，过程和个人是分开的。批评是针对产品和结果，而不是针对个人。



# 备忘

1. COCOMO模型
2. 面向对象的设计
3. 依赖倒置
4. 实心菱形和空心菱形（组合和聚合）

# 关于实验的总结

## 生命周期模型和敏捷开发

1. 结合自己的项目，分析采用的什么生命周期模型

采用敏捷开发模型，其特点包括

1. 个体和交互的价值胜于过程和工具
2. 可以工作的软件胜过面面俱到的文档
3. 客户合作胜于合同谈判
4. 响应变化胜于遵循计划

为什么

1. 人员因素：组内成员工程性经验较少，但是算法基础扎实，自学能力强。因此我们划分各自负责的模块之后自主学习并定期汇报，体现了敏捷开发中强调个体和交互的价值

2. 项目架构层面：由于经验的匮乏，我们不能保证在一开始的时候确定整体的功能框架，也不能保证每一个增量开发都是规模小、功能鲁邦的子系统。因此我们不采用瀑布模型。
3. 从开发角度：我们采用敏捷开发模型，可以及时扩展新的功能，并多次测试，及时的修正使用过程中出现的错误。



举例子

1. 在我们的小米便签实践中，需要不断向其中添加新的功能，并根据需求不断更新，这属于迭代开发。例如我们首先添加了便签排序功能，使便签可以按照时间先后进行排序。在此基础上，我们对便签类Note进行扩展，增加了优先级，并设置了按照自定义优先级排序的API。
2. 原始的小米便签只能输入文本，我们增加了插入图片的功能，并尽量不破坏原始的架构，这属于增量式开发。
3. 小组成员定期例会，并使用语雀进行记录，这体现了敏捷开发注重沟通和交流的特点。



## CASE工具调研分析

结合项目谈一下CASE

CASE全称是计算机辅助软件工程，通常与信息系统的开发方法以及可用于软件开发过程的自动化工具联系在一起。

在我们的实验中，我们主要采用Microsoft Visio（前身是微软Office Visio）作为CASE建模工具。visio是一个图表和矢量图形应用程序，提供了大多数框图的绘画功能，例如各种原理图，设计图，同时提供了大量组织结构图和流程图的案例。

相比于SmartDraw等软件，visio和word等办公软件的兼容性更好，可以更大程度上提高工作效率。





## 跟踪项目进展工具

### 项目进度跟踪——燃尽图和甘特图

我们的小米便签项目实践采用敏捷开发生命周期模型，利用燃尽图和甘特图对进度进行跟踪。

燃尽图（burn down chart）是在项目完成之前，对需要完成的工作的一种可视化表示。燃尽图有一个Y轴（工作）和X轴（时间）该图表是一个向下的曲线，随着剩余工作的完成，“烧尽”至零，提供了工作进展的公共视图。

甘特图通过条状图来显示项目、进度和其他时间相关的系统进展的内在关系随着时间进展的情况。并且，由于组成成员的空闲时间不一致，可以利用甘特图对工作时间进行管理。

### 组织结构

常见的组织结构有主程序员负责制和忘我方法。

- 主程序员负责制

  由一个主程序员负责系统设计和开发，其他成员向其汇报。主程序员对每一个决定有绝对的决策权。其特点是使交流最小化，可以迅速的作出决定，缺点是创造性低，对主程序员要求较高

- 忘我方法

  忘我方法中每一个成员都是平等的，过程和个人是分开的。批评是针对产品和结果，而不是针对个人。

我们的项目实践小组属于忘我方法组织结构，这也是我们立项的团队组织结构。原因如下

1. 人员配置：组内成员虽然专业基础扎实，但是缺少经验，没有合适的人选作为主程序员。因此，我们对项目进行初步的划分，每一个人负责一部分，平等的学习和讨论，并定期汇报
2. 工作方式：组内成员沟通交流方便，每周会组织定期的例会，对实验难点进行讨论。这种工作方式创造性更高，属于交流充分，减少开发周期翻去联调的项目实践方法。



## 需求获取、需求建模



### E-R建模

各种符号的含义



### 需求规格说明书SRS

软件需求说明是软件系统需求的规格化说明，是对将要开发系统的行为的说明。软件需求说明，顾名思义是对要开发的软件所要实现的需求的说明





## 需求建模



### 判定表

所有可能的输入事件(即函数调用)、条件和动作都列在表的左边，输入事件和条件列在水平线的上面，而动作列在水平线的下面。每一个列表示将一组条件映射到其对应结果的规则。一个单元格中的“T”意味着该行的输入条件为真，“F"意味着其输入条件为假，短划线表示条件的值无关紧要。表的下面部分的“X”的含义是，只要其对应的输入条件成立，该行的动作就应该执行



### Parnas

Parnas表(Parnas 1992)是数学函数和关系的表格式表示。和判定表一样，Parnas表使用行和列将函数的定义分割为不同的情况。表的每-一个条目要么指定部分地识别某些情况的一-个输入条件，要么指定某些情况的输出值。与判定表不同的是，Parmas表的输入和输出是纯数学表达式。

![img](https://cdn.nlark.com/yuque/0/2022/png/12831027/1651496989828-08be6490-b2c3-4ad8-be97-7ec4cb2ed035.png)



## 需求规格

### SRS文档

第一个方面是考虑到了读者背景，很多软件需求规格说明书对业务背景的读者照顾不足，这样会导致用户评审变得困难。而在国标SRS模板中能够说明不同背景的读者应该重点阅读哪些内容。
第二个方面是区分了用户的层次：高层用户关心业务需求（目标与范围），也就是偏重于阅读任务概述、目标这些小节；中层用户关心业务事件、Stakeholder关注点,也就是偏重于阅读每个子系统中的分解、流程图以及一些利益点分析；操作层用户关心业务活动，也就是偏重于阅读用例的描述。
第三个方面是划分了用户所属的业务区域，在国标SRS模板中能够体现这种区域划分，使读者能够更好地评审。



## SAD软件体系结构设计

### P203

![img](https://cdn.nlark.com/yuque/0/2022/png/26633445/1653313680774-57459d60-83c6-4efd-8116-a6940f44d426.png)

最接近分层架构风格，因为它被组织成多个部分，其中每个部分（付款人）主要与两侧的部分进行通信。



## 设计模块



### 德米特法则

德米特法则要求一个对象应该对其他对象尽可能少的了解。即任何一个对象，或者方法只能调用下列的对象

1. 当前对象本身
2. 以参数形式传入到当前对象方法中的对象
3. 当前对象的实例变量直接引用的对象
4. 当前对象的实例变量如果是一个聚类，那么聚类中的元素也都是朋友（也都可以调用）
5. 当前对象所创建的对象。

德米特法则的核心就是类间解耦，弱耦合，提高类的复用率。其设计的结果就是产生大量的中转或者跳转。



一般来说，德米特法则的设计具有更少的依赖，而类之间的依赖关系越少，软件的故障就越少，软件也越容易修改。



结合项目实践，就是在代码编写时尽可能少的对外公布public方法和非静态的public变量。多使用private和protected等关键词。

1. 在小米便签的后端设计中，请求链路是采用典型的MVC模型进行处理。一个请求抵达微服务之后，被Controller层接收。而Controller层持有的Spring依赖注入的Service层对象是被private关键字修饰的，因此根据德米特法则，在Controller层仅能调用其友元类Service对象，而对于其他对象尽可能少的了解。
2. 在调用了Service对象之后，根据德米特法则，在Servie层实现时，仅需要调用其友元Mapper对象去操作数据库，此时应该尽量减少对其他类对象的调用。



​	

### 依赖倒置

 依赖倒置原则的本质就是通过抽象(抽象类或接口)使各个类或模块实现彼此独立，不互相影响，实现模块间的松耦合。在项目中使用这个规则需要以下原则;

每个类尽量都要有接口或抽象类，或者抽象类和接口都有： 依赖倒置原则的基本要求，有抽象才能依赖倒置
变量的表面类型尽量是接口或者抽象类
任何类都不应该从具体类派生
尽量不要重写基类已经写好的方法(里式替换原则)
结合里式替换原则来使用： 结合里式替换原则和依赖倒置原则我们可以得出一个通俗的规则，接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。
一句话：依赖倒置原则的核心就是面向抽象(抽象类或者接口)编程



## 设计模块与测试

结合项目分析所用的设计模式

1. 工厂模式

工厂模式提供了一种创建对象的最佳方式，通过使用一个共同的接口来指向新创建的对象。具体来说就是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

在小米便签的项目中，最重要的类就是便签类Note，每一个便签都是一个Note对象，具有创建时间，内容等成员变量。在后期的项目扩展中，我们对便签的种类进行细分，分为生活类便签，工作类便签等。为了不破坏之前的接口，我们抽象出一个父类Note，其中包括了不同种类便签的公共功能，并让不同的便签类继承Note。在创建对象时，可以利用子类初始化父类，将类的创建延迟到子类进行。这种工厂化的设计模式既保留了原始的接口，又可以高效的常见复杂的类对象。



2. 策略模式

策略模式使得我们可以在运行时选择算法。当有多种方法可以应用于一个应用时，可以根据用户的需求或者实际的数据选择最合适的方法。

在我们的项目实践中，我们设计了多种便签排序方法，适应不同的用户需求，例如根据创建实践排序，根据标题的字典序排序等。在代码编写时，我们将不同的排序算法封装成独立的函数sort，这些函数的参数类型不同，因此可以重载。在对外的API中，我们将这些排序算法作为函数指针进行传递，即保证了对外接口的统一，也实现了多种排序算法的封装。



3. 装饰器模式

装饰器模式允许向一个现有的对象中添加新的功能，同时又不改变其结构，相比于生成子类更加灵活。

在小米便签的维护中，我们采用装饰器模式，添加了插入图片的功能。从代码编写的角度，我们用装饰器来包装原有的类Note，并在保持类方法签名完整性的前提下，提供了额外的功能insert。



4. 建造者模式

建造者模式使用多个简单的对象一步一步构建成一个复杂的对象，这种类型的设计模式属于创建型模式，提供了一中创建对象的最佳方式。

在小米便签功能的扩展中，我们添加了欢迎界面，并封装为Interface类。为了实现一些功能的复用，我们在Inferface类中组合了其他类对象，例如加入DateTimePicker用于显示时间，加入DropdownMenu类用于显示菜单，加入Carousel类用于在界面上显示轮播图。





