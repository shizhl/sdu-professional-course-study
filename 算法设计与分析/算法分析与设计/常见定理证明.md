[toc]

# 算法汇总

# 基本图算法

## BFS

### 引理22.1 相邻点最短路径相差小于等于1

![image-20211026151237393](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211026151237393.png)





### 引理22.2 算法求出的距离不小于实际最短距离

BFS求出来的距离d[v]一定大于等于最短路径

![image-20211026151304445](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211026151304445.png)





### 引理22.3 单调不减且极差小于1

在算法执行的过程中

1. 每一个时刻队列中每一个点的距离d[v]单调不减
2. 队列首部和队列尾部的点对应的距离d[v]相差小于1（距离极差大不于1）



### 推论22.4 先来为小（基于引理22.3）

算法执行过程中，先入队列的点对应的距离d[v]小

![image-20211010230305628](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211010230305628.png)



### 定理22.5 BFS算法正确性证明

BFS算法求解出来的就是最短路

（证明d[v]和实际最短路相互小于等于）





### 引理22.6 前驱子图就是BFS树生成

当在有向或者无向图G上执行BFS时，BFS过程中找到的前驱属性π使得前驱子图就是BFS生成树



## DFS

### 定理22.7 括号化定理



### 推论22.8 后代区间嵌套





### 定理22.9 白色路径定理





### 树边后向边定理

对无向图进行深度优先搜索时，每一条边只能是树边或者后向边，不能是前向边和横向边





## 拓扑排序

### 引理22.11 无环定理

一个有向图是无环的，当且仅当对其进行深度优先搜索时不产生后向边



### 定理22.12 拓扑算法正确性证明

算法生成的是有向无环图的拓扑排序



## 强联通分量

### 引理22.13 强联通分量之间不可双向可达



### 引理22.14（强连通分量）结束时间出大于入





### 推论22.15 转置图中强联通分量结束时间入大于出



### 定理22.16 强联通分量算法正确性证明







## 最小生成树

关于树的证明方法：

遇见一颗树和一条边：如果边不在树上，在先将该边加到树上，在删去环上一条边，构造一课新的树

如果在树上，则先删去那条边，在补上一条边。

> 树的性质：加入一条边，生成一个环；在删去环上的一条边，又变成树

### 一般化的证明

每一次都是找安全边，都是向着生成最小生成树的方向进行，且最终一定可以找到n-1条安全边

安全边：一个边加入到最小生成树的边的子集A之后，A还是最小生成树的边的子集。则边就是安全边

割：两个对立的点集

穿过：连接两个对立的点集的边

尊敬:描述割和边集的关系。边的两个端点都处于割中的同一个点集，则割尊敬边集A

轻边：权重最小的边



### 定理23.1 找安全边算法

对于安全边的集合A，如果一条边是穿过尊敬A的割的权重最小的轻边，则边就是安全边。

实际上就是说，如果穿过割的最轻的边一定是安全边

> 证明思路：
>
> 假设有一个割是（X,Y），A是MST的子集，边（u，v）是去穿过割的边中权重最小的
>
> 对边（u，v）是否在树上进行分类讨论
>
> 1. 如果本来就在树上，则一定成立
> 2. 如果不在树上，则==先把那条边加到树上==，形成一个环。
> 3. 删去环上一条边，构造一个新的树$T'$，则树$T’$的权重小于等于$T$,
> 4. 只能等号成立，因此$T'$的权重和只能等于$T$,所以$T'$也是最小生成树，且（u，v）属于$T'$，属于最小生成树



### kruskal算法

算法思想：先整体排序，之后从小到大检查每一条边是否连接了连个连通分量，直到跳出来n-1条边。

**证明思路**

> 1. ==任何时候挑出来的边都是MST的子集==
> 2. 最后一定能够挑出来n-1条边

像这种描述任何时候都满足的条件的算法证明，只需要证明**==“一开始是，变之前是，变之后也是==”**就行了，采用==**归纳法**==

1. 任何时候挑出来的边都是MST的子集

> (1)开始时，空集一定是任何集合的子集
>
> (2)假设$A_k$是MST的子集，需要证明$A_{k+1}$也是
>
> $A_k$对应的边导出子图是森林，以其中一个树为割的一半，其他所有树作为割的另外一半，则构造出来了一个割，从两个点集中分别取出一个，构造边(u,v)，找出权重最小的，就是轻边，也是安全边。

2. 最后一定能够挑出来n-1条边

> 反证法：假设最后跳出来的不够，则一定还可以再继续挑





### Prim算法

其实和最短路算法一样，只不过对于距离数组的定义不同。

需要维护三个数据结构：

> 1. Q：Q存储未确定key[]值的点
> 2. U：Q相对于全集V的补集，与Q形成割
> 3. key[]:key[v]=W((u,v)),u是队列里面的点
> 4. 堆：每一次从未确定key值的点中选取一个key最小的点出来

**证明思路**同上

> 1. ==任何时候挑出来的边都是MST的子集==
> 2. 最后一定能够挑出来n-1条边 





## 最小生成树的性质

### 图中权重最小的边一定至少包含在一个最小生成树中

设权重最小的边为e,则加入这条边，形成一个环，在删去环上一条边，得到了权重小于等于最小生成树T的$T'$,因此二者权重相等，所以$T'$也是MST，因此e属于$T'$，即e属于MST



### 对应位置全局权重最小

对最小生成树$T$和其他所有生成树$T’$ 的边按照权重升序排序，则T中第$i$小的边，一定比任意一个$T'$中第小的边$i$权重小。

<img src="D:\QQfile\1172159897\FileRecv\96AF39E68B416AFFF1768964950D5550.png" alt="96AF39E68B416AFFF1768964950D5550" style="zoom:33%;" />

<img src="D:\QQfile\1172159897\FileRecv\54B4A58CCC699C65E17EB8959516DAA3.png" alt="54B4A58CCC699C65E17EB8959516DAA3" style="zoom: 33%;" />

### 如果图中的每一条边的权重都不一样，则图的最小生成树是唯一的

每一个边的权重不同，说明每一个生成树的边权按照升序排列都是唯一的。

则假设有有两个MST，对应位置相互小于等于，则二者必定相等。



# 最短路径算法（每年必考）

## 关于松弛操作的有关性质

==**松弛操作**==

```cpp
if(d[v]>d[u]+w(u,v)){
    d[v]=d[u]+w(u,v);
    pi[v]=u;
}
```

![image-20211024221516803](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211024221516803.png)



## 关于最短路的有关性质

最短路的隐含条件：

1. 最短路不能包含负环
2. 最短路上也不能有权重和为正数的环路
3. 最短路一定是无环的，
4. 最短路的边数一定小于等于点数减一

### 定理24.1 最短路的子路都是最短路

假设有一段子路$P$不是从u到v的最短路，则一定存在一条最短路$P'$从u到v。

那么将原来最短路中的$P$部分换成$P'$，则得到一条更短的路，最短路的定义矛盾

因此最短路的子路一定是最短路。

![image-20211024214657718](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211024214657718.png)

![image-20211024221516803](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211024221516803.png)

> 1. 三角不等式：
>
>    1. 证明思路：普通路的程度一定大于最短路的长度
>    2. 当且仅当u在s到v的最短路上时，等号成立
>
> 2. 收敛性：也就是说当已知最短路存在时，则按照最短路上的点序列（边序列）去松弛边，依次可以得到起点到该路径上各个点的最短路
>
> 3. 路径松弛性质：当最短路径存在时，如果最短路径上的边是松弛边序列的一个子序列，则最后一定可以得到一个最短路径。
>
>    描述的是最短路径和松弛边顺序的关系



## 最短路径树

当所有点的满足==$d[v]=σ(s,v)$==，则边集==$\{v,π[v]\}$==构成了一个最短路径树

需要证明：

> 1. 包含且仅包含了起点s可以到达的点
>
>    (可以使用点集==$\{s\}U\{v|π[v]!=φ\}$==）
>
>    这个性质也说明了，当一个点的前驱存在时，起点到该点一定有路，且$d[v]<无穷大$
>
> 2. 这个图是一个以s为根的树
>
>    （==证明无环，如果有环则一定是负环==）
>
> 3. 从s到每一个点的路是唯一的，且是最短路
>
>    (根据上述1和2，显然成立)



## 单源点最短路

### Bellman-Ford Algorithm

作用：

> 1. 适用于含有负权的图
> 2. 能够检测图中是否有负环

两层循环，内循环枚举每一条边，外循环控制内循环的执行次数为v-1次。

#### 证明如果存在负环则可以return false

> 只需要证明当松弛完n-1次之后，还存在边可以被松弛则存在 <==>负环即可
>
> 等价于证明：如果有负环，则松弛完n-1次轮之后，还存在边可以被松弛
>
> 等价于证明：如果存在负环，则松弛完n-1轮之后，没有边可以再次被松弛是矛盾的

### 在DAG（有向无环图）上的最短路算法

按照拓扑序列的顺序去松弛每一个点的临边，最后可以得到从源点到每一个点的最短路

（假设起点为s，则上述算法先松弛s之前的点，在松弛s之后的点）

<img src="file:///D:\QQfile\1172159897\Image\C2C\F9DA25E7AE4035A078A4B1025680E668.png" alt="img" style="zoom:50%;" />

