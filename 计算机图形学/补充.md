描述 Cohen-Sutherland 裁剪算法。

对于每一条线段P1P2分为三种情况处理

（1）若线段P1P2完全在窗口内部，则直接显示该线段，简称“取”

（2）若线段P1P2明显在窗口外，则直接丢弃该线段，简称“弃”

（3）若线段局部满足“取”，又不满足“弃”，则在交点处将线段分为两段，其中一段完全在窗口外，可弃之。然后重复对另一段重复上述处理。

为了快速判断一条直线和窗口属于何种关系，采用如下方式编码，延长窗口的边，将平面划分为9个区域，每一个区域$C_tC_bC_rC_l$赋予4位编码，其中每个位的定义如下

![image-20220102082342564](E:\计算机图形学\pic\image-20220102082342564.png)

裁剪一条直线时，先求出P1P2所在的区号code1,code2，若code1=code2=0,则线段P1P2在窗口内部，应该取之。若按位与运算code1&code2!=0,则说明两个端点同在窗口的上方，下方，左方或者右方。可判断窗口完全在串口外，可以弃之。

否则按照第三种情况处理：求出线段和窗口的交点，在交点处将线段一分为二，一种必有一段在窗口外，可以弃之。对另一段重复上述操作。

在求交点时，不必把线段与每一条窗口边界依次求交，只需要按顺序检测到端点的编码不为0，才将线段与对应的窗口边界求交。





![image-20220102082814184](E:\计算机图形学\pic\image-20220102082814184.png)![image-20220102082832518](E:\计算机图形学\pic\image-20220102082832518.png)













































多边形扫描填充算法思想和伪代码

思想：多边形扫描转化是按照扫描线的顺序，计算扫描线与多边形的相交区间，在使用颜色显示这些区间的像素，即可完成填充工作。区间的端点可以通过计算扫描线与多边形边界线的交点获得，对于一条扫描线，多边形的填充可以分为四个步骤：

1. 求交：计算扫描线与多边形各边的交点
2. 排序：将所有交点按照x值递增的顺序排列
3. 配对：将第一个与第二个，第三个与第四个等的交点配对，每对交点代表扫描线与多边形的一个相交区间。
4. 填色：把相交区间内的像素值设置为多边形的颜色，把相交区间外的像素设置为背景色。

为了提高求交的效率，可以利用图形的连贯性，引入多边形边表，活性边表等数据结构，利用增量算法避免求交运算

```cpp
void PolygonFill(polygon,color){
 	for(每一条扫描线i){
        初始化多边形边表NET[i];
        将y_min=i的边放入NET[i];
    }   
    y=最低的扫描线;
    初始化活性边表AET为空;
    for(每一条扫描线){
        将NET[i]中的边节点用插入排序法插入AET中，使其按照x坐标递增的顺序排列;
        若允许多边形自交，则使用冒泡排序;
        遍历AET，将配对的交点区间（左闭右开）上的像素填充为指定颜色;
        遍历AET，将y_max=i的节点从AET中删除，并把y_max>i的节点的x值递增delt_x;
    }
}
```



​	





































线消隐算法

线消隐算法中，最基本的是判断面对线的遮挡关系

1. 若线段的两个端点以及视点在给定平面的同侧，则线段不被指定平面遮挡，转7

2. 若线段的投影与平面投影的包围盒无交点，则线段不被指定的平面遮挡，转7

3. 求直线与相应无穷平面的交点

   若无交点，转4，否则交点在线段的内部或外部

   若交点在线段内部，则交点将线段分为两段，与视点同侧的一段不被遮挡，另一端在视点的异侧，转第4步。

   若交点在线段外部，转第四步

4. 求所剩线段的投影和平面投影的所有交点，并根据交点在原直线参数方程中的参数值求出Z深度，若无交点，则转5

5. 以上所求的交点将线段的投影分为若干段，求出第一段的中点

6. 若第一段的中点在平面的投影内，则相应的段被遮挡，否则不被遮挡，其他段的遮挡关系可以依次交替判断。

7. 结束

   

   