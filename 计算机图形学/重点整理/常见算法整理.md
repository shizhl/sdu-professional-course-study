[toc]

# 第二章常见算法整理

## 直线段的扫描转换算法

### 数值微分法





### 中点画线法



### Bresenham算法





## 圆弧的扫描转换算法

### 中点画圆法



## 多边形扫描转换算法

### 多边形的扫描转换

#### ==扫描线算法==



#### 边界标志算法





### 区域填充算法

#### 区域填充递归算法



#### 区域填充的扫描线算法



## 裁剪

### 直线段裁剪

#### Cohen-Sutherland算法

算法概述





#### 中点分割裁剪算法



#### ==梁友栋-Barskey算法==



​                                                                                                                                                                                                                        

### 多边形裁剪

#### Sutherland-Hodgman算法



## 反走样

定义：使用离散量表示连续量引起的失真现象成为走样

用于减少或者消除这种效果的技术成为反走样。

### 提高分辨率



### 区域采样

算法描述：

> 区域采样算法假定每一个像素是一个具有一定面积的小区域，将直线段看做是具有一定宽度的狭长矩形。当直线段与像素有交点时，求出两者向郊区与的面积，然后根据相交区域面积的袋熊确定像素的亮度值。



算法优点：

> 1. 效果较好
> 2. 可以采用离散的方法简化计算

算法缺点：

> 1. 像素的亮度与相交区域的⾯积成正⽐，⽽与相交区域落在像素内的位置⽆关，这仍然会导致锯⻮效
> 2. 直线条上沿理想直线⽅向的相邻两个像素有时会有较⼤的灰度差



### 加权区域采样

算法描述：

> 1. 将直线段看作是具有⼀定宽度的ሀ⻓矩形。当直线段与像素有交时，根据相交区域与像素中⼼距离 来决定其对像素亮度的贡献。 
> 2. 直线段对⼀个像素的亮度的贡献正⽐于相交区域与像素中⼼的距离。设置相交区域⾯积与像素中⼼ 距离的权函数 (⾼斯函数) 反映相交⾯积对整个像素亮度的贡献⼤⼩

![image-20211009201317493](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211009201317493.png)

## 消隐

### 消除隐藏线

#### 平面对直线段的遮挡判断算法P44-算法程序2.14

```cpp
1. 
```



#### 线消隐算法

算法伪代码

```cpp
void HiddenLineRemove(){
    坐标变换;
    for(对每一个面的每一条边Ei)，将二元组<Ei,j>压入堆栈;
    while(栈不空){
    	取出栈顶元素<Ei,j0>;
        for(j!=j0的每一个面Fj){
            if(Ei被Fj全部遮挡){
                将Ei清空;
                break;
            }
            if(Ei被Fj部分遮挡){
            	将遮挡的部分裁减掉;
                if(Ei被分为若干段){
                    去除其中一段作为当前段;
                    将其他段以及对应j压栈;
                }
            }
        }
        if(Ei段不空){
            显示Ei;
    }
}
```





### 消除隐藏面

#### 画家算法

1. 算法核心思想

> 1. 初始化屏幕为背景色 

2. 算法优点

> 1. 原理简单

3. 算法缺点

> 1. 只能处理不想交的面 并且深度优先级表中的面的顺序很可能出错。
> 2. 在两个面相交是三个以上的面重叠的情形 使用任何的排序算法都不能得出正确的结果。需要将有关的面进行分割后在处理
> 3. 深度排序的计算量大，排序后需要再检查相邻的面，以确保在深度优先级表中前者在前 后者在后





#### Z缓冲区算法

1. 算法核心思想

> 除了维护帧缓存存放每一个像素的取值，还需要一个深度缓存来存放每一个像素的深度值。图像消隐的过程就是给帧缓冲区和Z缓冲区中相应单元添值的过程

2. 算法伪代码

```cpp
Z-Buffer(){
    帧缓存全置为背景色;
    深度缓存全置为最小值Zmin;
    for(每一个多边形){//枚举多边形
    	扫描转换该多边形;
        计算该多边形在该像素的深度值Z(x,y);
        if(Z(x,y)> Z缓冲区在(x,y)处的值){
        	把Z(x,y)存入Z缓冲区的(x,y)处;
            把多边形在(x,y)处的颜色存入帧缓存区的(x,y)处；
        }
    }
}
```

3. 算法优点：

> 1. 算法简单 直观
> 2. 在像素级别上以近物取代远物，与物体在屏幕上出现的顺序是无关紧要的，友路与硬件的实现。

4. 算法缺点

> 1. 占用空间大
> 2. ==没有利用图像的相关性和连续性==（**严重缺陷**）
> 3. ==该算法是在像素级别上的消隐算法==（**很大缺点**）



#### 多面体消隐的改进深度缓存算法

1. 算法改进：

> 只使用一个深度缓存变量zb代替与图像大小相等的缓存数组 节省了空间

2. 算法伪代码

```cpp
Z-Buffer-update(){
    帧缓存全部置为背景色;
    for(屏幕上每一个像素(i,j)){
        初始化多边形的序号indexp=0;//用于记录最终显示哪一个多边形的颜色
        深度缓存变量zb置为最小值Zmin;
        for(多面体上的每一个多边形Pk){
            if(像素点(i,j)在Pk的投影多边形之内){//如何判断点是否在多边形内
                计算Pk在点(i,j)出的深度值depth;//如何计算深度值
                if(depth>zb){
                    zb=depth;
                    indexp=k; 记录多边形的序号
                }
            }
        }
        if(zb!=Zmin){
            计算多边形p在交点(i,j)处的光照颜色并显示;
        }
    }
}
```



3. 如何判断像素是否在多边形内部

- 射线法

> 1. 核⼼：由被测点 处向 ⽅向作射线，交点个数是奇数，则被测点在多边形内部；交点 个数是偶数表示在多边形外部
> 2. 若射线正好经过多边形的顶点，则采⽤ "左开右闭" 的原则来实现。即：当射线与某条边的顶点相 交时，若边在射线的左侧，交点有效，计数；若边在射线的右侧，交点⽆效，不计数
> 3. 缺点：计算量⼤、不稳定 (浮点误差)

![image-20211007064121813](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211007064121813.png)





- 弧⻓法

> 核⼼：以 点为圆⼼，作单位圆，把边投影到单位圆上，对应⼀段段弧⻓，规定逆时针为正，顺时 针为负，计算弧⻓代数和。
>
>  代数和为 0，点在多边形外部；代数和为 2π，点在多边形内部；代数和为 π，点在多边形边上

![image-20211007064229930](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211007064229930.png)



- 以顶点符号为基础的弧⻓累加⽅法

> 核⼼： 是被测点，按照弧⻓法， 点的代数和为 2π。不要计算⻆度，做⼀个规定来取代原来的弧 ⻓计算。
>
>  在边上与内部均为 2π，外部为0。

![image-20211007064311069](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211007064311069.png)

![image-20211007064342536](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211007064342536.png)





#### 扫描线Z-Buffer算法

1. 算法思想

> 在Z-Buffer算法的基础上，利用连续性提高点和多边形的包含性测试和深度计算的速度。
>
> 1. 在处理当前扫描显示，开辟一个一维数组作为当前扫描线的Z-Buffer。
>
> 2. 找出与当前扫描线相关的多边形以及每一个多边形中相关的边对
> 3. 计算每一个边对之间的区间上个像素的深度，并与Z-Buffer中的值进行比较。找出个像素处对应的可见平面，计算颜色，写入帧缓存。
> 4. 对深度的计算可以采用增量计算



算法优点

> 1. 将整个绘图窗口内的消隐问题分解到一条条扫描线上解决。使所需要的Z缓冲区大小减小。
> 2. 计算深度值时，利用面的连贯性，只使用了一个加法。

算法缺点

> 1. 每一个像素处都计算深度值，并进行深度比较。因此被多个多边形覆盖的像素区处需要进行多次的计算，计算量大。



算法伪代码

```cpp
Z-Buffer-scanline(){
    建立多边形Y表;
    多于一个多边形顶点的最小值ymin,将该多边形置入多边形Y表达相应位置;
	for(每一条扫描线i，i从小到大){
        1. 帧缓存CB设置为背景色;
        2. 深度缓存ZB（一维数组）设置为负无穷大;
        3. 将对应扫描线i的，多边形Y表中的多边形加入到活化多边形表APT中。;
        4. 对于新加入的多边形 生成对应的边表ET;
        for(每一个新加入的多边形){
            生成其对应的边表ET;
        }
        5. 对于APT中的每一个多边形，如果其变白哦ET中对应扫描线i增加了新的边，将新的边配对 加入到活化边对表AET中。;
        for(APT中每一个多边形P){
        	if(P中边表对应扫描线i增加了新的边){
                将新边配对，加入到活化边对表AET中。
            }
        }
        6. 对于AET中的每一对边：
        	6.1 对于xl<j<xr的每一个像素(i,j)，按照增量公式z=z+derta(z),计算各点的深度depth;
        	6.2 与ZB中的对应量ZB(j)比较 ，如果depth>ZB(j),则零ZB(j)=depth,并计算相应颜色值，写入帧缓存;
        for(AET中的每一对边){
            for(对于边对左右区间xl,xr中的每一个像素(i,j)){
                按照增量公式计算z=z+derta(z);
                计算深度值depth;
            	if(ZB[j]<depth){
					ZB[j]=depth;
                    计算颜色值，更新帧缓存;
                }
            }
        }
        7. 删除APT中多边形顶点最大y坐标Ymax为i的多边形，并删除相应的边;//多边形?????????
        for(APT中每一个多边形){
        	if(Ymax<=i){
                删除相应的边;  //????????????????????
                //删除相应的多边形;
            }
        }
        8. 对于AET中的每一个边对，作出如下处理
        	8.1 删除ylmax或yrmax已等于i的边。如果一个边对中只删除了其中一条边，需要对该多边形的边重新配对
            8.2 利用增量公式计算新的xl、xr以及z，即
           	xl=xl+derta(xl),xr=xr+derta(xr),z=z+derta(xl)*derta(za)+zb;
        for(AET中的每一个边对){
            if(ylmax<=i||yrmax<=i){
                删除相应边，重新配对;
            }
            xl=xl+derta(xl),xr=xr+derta(xr),z=z+derta(xl)*derta(za)+zb;
        }
    }
}
```

精简版伪代码：

```cpp
void Z-buffer(){
    建立多边形Y表;对每一个多边形根据顶点的最小y值将多边形置入多边形Y表;
    新建活化多边形表APT和活化边对表，并初始化为空;
    for(每一条扫描线){
   		1.帧缓存置为背景色;
        2.深度缓存ZB置为负无穷大;
        3.将多边形Y表中对应扫描线i的多边形加入到活化多边形表APT中;
        4.对新加入的多边形，生成其对应的边表ET;
        5.对APT中的每一个多边形，若其边表ET中对应扫描线i增加了新的边，将新的边配对，加入到活化边对表AET中;
        for(对AET中的每一对边){
        	for(对xl<j<xr的每一个像素){
                按照增量公式z=z+derta(za)，计算各点的深度值depth;
	        	if(depth>ZB(j)){
                    ZB(j)=depth;
                    计算颜色值，写入帧缓存;
                }
            }
        }
        7.删除APT中多边形顶点最大Y坐标为i的多边形，并删除相应边;
        for(AET中的每一条边){
            删除ylmax或者yrmax已经等于i的边，如果一对边中只删除了其中一条，则重新配对;
            利用增量公式，更新xl，xr和zl;
            xl=xl+derta(xl);
            xr=xr+derta(xr);
            zl=zl+derta(xl)*derta(za)+derta(zb);
        }
    }
}
```



初始化三个表

遍历扫描线

初始化两个缓存 

新多边形加入APT，并生成对应边表

遍历APT，新边配对并加入活化边对表AET

遍历边对表，计算边上每一个点的深度值并与深度缓存中的值比较，大则更新深度缓存和帧缓存

删除APT中多边形定点最大y坐标小于当前y值的，并删除相应边

遍历边对表，首先删除ylmax或者yrmax已经等于i的边，如果只删除了边对中的一条，则重新配对。

其次利用增量公式，更新边对表中的xl，xr和zl



#### 区间扫描线算法

1. 算法核心思想

> 考虑Z-Buffer没有利⽤图形的相关性和连续性的缺陷，该算法放弃了Z-Buffer的思想
>
> 扫描线算法使得在一条扫描线上的每一个区间只计算一次深度值，并且不需要Z缓冲器。
>
> 将当前扫描线与各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间。因此只需要在区间内任找一点，找出该处Z值最大的一个面，这个区间上的每一个点的像素就用这个面的颜色来表示。

![image-20211007074518873](C:\Users\shizhengliang\AppData\Roaming\Typora\typora-user-images\image-20211007074518873.png)

> 确定⼩区间的颜⾊： 
>
> 1. ⼩区间⽆任何多边形，如[a4, a5]，⽤背景⾊显示 
> 2. ⼩区间仅有⼀多边形，如[a1, a2]，显示该多边形颜⾊ 
> 3. ⼩区间存在两个以上多边形，如[a6, a7]，⽤深度检测
> 4. ==**如果允许物体表现相互贯穿，则必须求出他们在扫描平面的交点，利用这些交点把该小区间分成更小的子区间。在这些间隔上决定那个多边形可见。**==





#### 区域分割扫描线算法（Warnack算法）

算法概述(基本思想)

> 将物体投影到全屏幕窗口上，然后递归分割窗口，直到窗口足够简单，可以显示为止

算法描述（==也成为四叉树算法==）

> 1. 把初始化窗口取做屏幕坐标系的矩形，将场景中的多边形投影到窗口内。
> 2. 如果窗口内没有多物体，则按照背景颜色显示；
> 3. 如果窗口内只有一个物体，则将该面显示出来。
> 4. 如果窗口内有两个面，则将窗口进行四等分，分成四个小窗口。对每一个小窗口在做上述同样的处理。
>    1. 如果窗口分割到仅有像素那么大，而窗口上仍有两个或者两个以上的面，则此时不用在分割，只需要取距离窗口最近的可见面的颜色或者所有可见面颜色的平均颜色作为该点像素的值。



下列情况之一可以直接显示颜色

> 1. 所有多边形均与窗口分离，该窗口显示背景色
> 2. 只有一个多边形与窗口相交，或该多边形包含窗口，则现将整个窗口设置为背景色，之后再对多边形在窗口内部分扫描线算法绘制
> 3. 有一个多边形包围了窗口，或者窗口与多个多边形相交，但是一个多边形包围窗口且在最靠近观察点

算法伪代码

```cpp
void Warnack(){
    新建一个栈stack,并将全屏幕窗口(0,0,1024)压入栈内;
    while(栈为空){
        从栈中弹出一个窗口(x,y,s),s为边宽;
        检查窗口与物体的覆盖关系;
        if(窗口内目标简单){
            显示窗口内目标;
        }
        else if(边宽s<=1){
            显示该像素;
        }
        else{
            s/=2;
            将窗口分为四个子窗口:(x,y,s),(x+s,y,s),(x,y+s,s),(x+s,y+s,s)并依次入栈;
        }
    }
    return ;
}
```







#### 光线投射算法

> 光线投射算法和Z缓冲区算法相比，近视内外层循环进行了颠倒，算法复杂度类似。
>
> 相较于Z缓冲区算法，光线投射算法不需要Z缓冲区。

算法改进

> 为了提高算法的效率，可以使用包围盒技术、空间分割技术以及物体的层次表示方法来加速。

算法为伪代码

```cpp
for(屏幕上的每一个像素){
    形成通过该屏幕像素(u,v)的射线;
    for(场景中的每一个物体){
        将该射线与物体求交;
    }
    if(存在交点){
        以最近的交点显示像素(u,v);
    }
    else{
        以背景颜色显示像素;
    }
}
```



# 第三章常见算法整理

## 参数曲线的代数表示

### 参数曲线的几何表示——

