[toc]

# 复习

## 基础背记知识

## 光栅化算法

### 直线段扫描算法



### 多边形扫描转化

#### 扫描线算法

```cpp
void polyfill(polygon ,int color){
    for(各条扫描线){
        初始化新编表头指针NET[i];
       	将y_min=i的边放入新边表NET[i];
    }
    y=最低扫描线号;
    初始化活性边表为空;
    for(各条扫描线){
        将NET[i]中的便捷地啊你使用插入排序插入到活性边表AET中，是指按照x坐标递增的顺序排列;
        若语序多边形的边自交，则使用冒泡排序对活性边表进行重新排序;
        遍历活性边表AET,将配对交点的区间（左闭右开）上的像素（x,y）着上对应的颜色;
        遍历活性边表AET,将y_max=i的节点从活性边表中删除，并把y_max>i的节点的x值递增 dx;
    }
}
```



#### 边标志算法

```cpp
void edgemark_fill(polydef,color){
    对多边形的每一条边进行扫描转化;
    将多边形边界经过的每一个像素打上标志;
    for(每一条与多边形polydef相交的扫描线y){
        inside=False;初始化为false;
        for(扫描线上的每一个像素){
            if(像素x被打上了边标志)
            {
            	inside=!(inside);
            }
            if(inside){
                当前像素点着色为指定填充色color;
                drawPixel(x,color);
            }
            else{
                当前像素点着色为背景色;
                drawPixel(x,background);
            }
        }
    }
}
```



### 区域填充算法





### 反走样

走样：使用离散化表示连续量引入的失真现象称为走样

反走样：用于减少或者消除这种效果的技术称为反走样

基本方法：

> 1. 提高分辨率
> 2. 区域采样：
>    1. 基本思想：假定每一个像素是一个具有一定面积的小区域，将直线段看做是具有一定宽度的狭长矩形。当之下暖和像素有交点时，求出二者相交区域的面积，然后根据相交区域的面积大小确定像素的亮度值。
>    2. 非加权采样的缺点
>       1. 像素的亮度与相交区域的面积成正比，而与相交区域落在像素内的位置无关，这仍然会产生锯齿效应。
>       2. 直线条上沿立项直线方向的相邻两个像素有时会有较大的灰度差
> 3. 加权区域采样：
>    1. 基本思想：使用加权区域采样的方法，使相交的区域对像素亮度的贡献依赖于区域与像素中心的距离。当直线经过该像素时，该像素的亮度F是二者在相交区域上对滤波器函数积分的积分值



### 消隐

#### 平面对直线段的遮挡判断算法

1. 若直线的端点以及视点在给定平面的同侧，则线段不被给定平面遮挡
2. 若线段的投影与平面投影的包围盒和无交点，则线段不被给定平面遮挡
3. 求直线与相应无穷平面的交点，若无交点，则转第四步；否则，交点在线段内部或者外部。若交点在线段内部，则交点将线段分成两段，与视点同侧的一段不被遮挡，另一段在视点另一侧
4. 求所剩线段的投影与平面边界投影的所有交点，并根据交点在原直线参数方程中的参数值求出Z值（即深度）。若无交点，则转第五步
5. 以上所求的各个交点将线段的投影分成若干段，求出第一段中点
6. 若第一段中点在平面的投影内，则相应的线段被遮挡，否则不被遮挡。==其他线段的遮挡关系可以依次交替取值进行判断==

#### 线消隐算法



